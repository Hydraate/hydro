//
//                 __  __            __           
//                / / / /__  __ ____/ /_____ ____ 
//               / /_/ // / / // __  // ___// __ \
//              / __  // /_/ // /_/ // /   / /_/ /
//             /_/ /_/ \__, / \__,_//_/    \____/ 
//                    /____/                      
//
//              The Hydro Programming Language
//

#ifndef __h3o_internal_Lexer__
#define __h3o_internal_Lexer__

#include <map>
#include <regex>
#include <vector>

#include "ErrorReporter.hpp"
#include "SourceBuffer.hpp"
#include "Token.hpp"

namespace hydro::compiler {

/**
 *
 */
const std::regex lexer_identifier{ "^[a-zA-Z_][a-zA-Z0-9_]*" };

/**
 *
 */
const std::regex lexermLinefeed{ "^[\\n]+$" };

/**
 *
 */
const std::regex lexer_whitespace{ "^[\\s\\t\\r]+$" };

/**
 *
 */
const std::regex lexer_singlemLine_comment{ "^\\/\\/[^\n]*$" };

/**
 *
 */
const std::regex lexer_alpha{ "^[a-zA-Z]+" };

/**
 *
 */
const std::regex lexer_letter{ "^[a-zA-Z]$" };

/**
 *
 */
const std::regex lexer_alphanum{ "^[a-zA-Z0-9]+" };

/**
 *
 */
const std::regex lexer_alphanum_underscore{ "^[a-zA-Z0-9_]+$" };

/**
 *
 */
const std::regex lexer_digit{ "^[\\d]+$" };

/**
 *
 */
const std::regex lexer_number{ "^(([0-9]+(([dDfFrR])|([uU]?[lLsS])))|([1-9][0-9]*([eE](\\+|\\-)?[0-9]+)?)|(0)|(0[0-7]+([eE](\\+|\\-)?[0-9]+)?)|(0[bB][0-1]+)|(0[xX][a-fA-F0-9]+)|(([0-9]+\\.[0-9]+)([eE](\\+|\\-)?[0-9]+)?([dDfFrR])?))$" };

/**
 *
 */
const std::regex lexer_double{ "^[0-9]+\\.[0-9]+([eE][\\+\\-]?[0-9]+)?$" };

/**
 *
 */
const std::regex lexer_int{ "^[1-9][0-9]*([eE](\\+|\\-)?[0-9]+)?(([dDfFrR])|([uU]?[lLsS]))?$" };

/**
 *
 */
const std::regex lexer_octal{ "^0[0-7]+$" };

/**
 *
 */
const std::regex lexer_octal_digit{ "^[0-7]$" };

/**
 *
 */
const std::regex lexer_binary{ "^0[bB][0-1]*$" };

/**
 *
 */
const std::regex lexer_binary_digit{ "^[0-1]$" };

/**
 *
 */
const std::regex lexer_hexadecimal{ "^0[xX][0-9a-fA-F]+$" };

/**
 *
 */
const std::regex lexer_hexadecimal_digit{ "^[0-9a-fA-F]$" };

/**
 *
 */
class Lexer
{
protected:
    
    /**
     *
     */
    Lexer();
    
    /**
     *
     */
    Lexer(ErrorReporter* errorReporter);

public:
    /**
     *
     */
    virtual ~Lexer();

    /**
     *
     */
    void load(SourceBuffer* input);

    /**
     *
     */
    bool hasNext() const;

    /**
     *
     */
    Token nextToken();

    /**
     *
     */
    Token nextToken(int32_t pos);

    /**
     *
     */
    Token nextChar();

    /**
     *
     */
    Token nextChar(int32_t pos);

    /**
     *
     */
    Token charAt(int32_t index);

    /**
     *
     */
    Token lookChar(int32_t k);

    /**
     *
     */
    std::string getTokenName(Token token);

    /**
     *
     */
    std::string getTokenName(std::string tokenValue);

    /**
     *
     */
    std::string getTokenName(int tokenType);

    /**
     *
     */
    ErrorReporter* getErrorReporter() const { return mErrorReporter; }

    /**
     * Gets the token that was the most recent token to be generated by the lexer.
     * @return Returns a Token object.
     */
    Token currentToken() const { return mCurrentToken; }

    /**
     *
     */
    SourceBuffer* input() const { return mInput; }

    /**
     *
     */
    int32_t getPosition() const { return mPos; }

    /**
     *
     */
    uint32_t line() const { return mLine; }

protected:
    /**
     *
     */
    struct TokenInfo
    {
        std::string name;
        std::string value;
        int32_t type;
        TokenInfo(std::string n, std::string v)
          : name{ n }
          , value{ v }
          , type{ 0 }
        {}
        TokenInfo(std::string n, int32_t t)
          : name{ n }
          , value{}
          , type{ t }
        {}
        ~TokenInfo() {}
        bool compare(std::string tokenValue) const { return value == tokenValue; }
        bool compare(int32_t tokenType) const { return type == tokenType; }
    };

    /**
     *
     */
    struct TokenPattern
    {
        int32_t type;
        std::regex pattern;
        char sentinel; // terminating character
        TokenPattern(int32_t t, std::regex p, char s = '\n')
          : type{ t }
          , pattern{ p }
          , sentinel{ s }
        {}
        ~TokenPattern() {}
    };

    /**
     *
     */
    std::vector<TokenInfo*> mTokenNames;

    /**
     *
     */
    std::vector<TokenPattern*> mTokenPatterns;

    /**
     *
     */
    Token mCurrentToken;

    /**
     *
     */
    Token mEofToken;

    /**
     *
     */
    SourceBuffer* mInput;

    /**
     *
     */
    std::string mBuffer;

    /**
     *
     */
    std::string mSpecBuffer;

    /**
     *
     */
    int32_t mSpecPos;

    /**
     *
     */
    std::vector<int32_t> mMarkers;

    /**
     *
     */
    int32_t mTokenPos;

    /**
     *
     */
    int32_t mPos;

    /**
     *
     */
    uint32_t mLine;

    /**
     *
     */
    ErrorReporter* mErrorReporter;

    /**
     *
     */
    std::string mContent; // loaded content

    // arbitrary lookahead
    char la(int32_t k);

    // buffering
    std::string buffer() const { return mBuffer; }

    /**
     *
     */
    std::string bufferWithCurrent() { return currentChar() ? mBuffer + currentChar() : ""; }

    /**
     *
     */
    std::string bufferWithNext() { return hasNext() ? mBuffer + la(1) : ""; }

    /**
     *
     */
    Token flush(int32_t tokenType);

    /**
     *
     */
    void registerTokenName(std::string tokenValue, std::string tokenName);

    /**
     *
     */
    void registerTokenName(int32_t tokenType, std::string tokenName);

    /**
     *
     */
    TokenInfo* findTokenName(std::string tokenValue) const;

    /**
     *
     */
    TokenInfo* findTokenName(int32_t tokenType) const;

    /**
     *
     */
    void registerTokenPattern(int32_t tokenType, std::string pattern);

    /**
     *
     */
    void registerTokenPattern(int32_t tokenType, std::string pattern, char sentinel);

    /**
     *
     */
    void registerTokenPattern(int32_t tokenType, std::regex pattern);

    /**
     *
     */
    void registerTokenPattern(int32_t tokenType, std::regex pattern, char sentinel);

    /**
     *
     */
    TokenPattern* findTokenPattern(int32_t tokenType) const;

    /**
     *
     */
    void reportError(std::string errorTxt);

    /**
     *
     */
    void reportWarning(std::string warningText);

    /**
     *
     */
    bool isEof(int32_t k);

    /**
     *
     */
    bool matchLa(char ch, int32_t k);

    /**
     *
     */
    bool matchLa(const std::regex& pattern, int32_t k);

    /**
     *
     */
    bool matchLa(int32_t registeredTokenType, int32_t k);

    /**
     *
     */
    bool matchBuffer(const std::regex& pattern);

    /**
     *
     */
    bool matchBuffer(int32_t registeredTokenType);

    /**
     *
     */
    bool matchBufferWithCurrent(const std::regex& pattern);

    /**
     *
     */
    bool matchBufferWithCurrent(int32_t registeredTokenType);

    /**
     *
     */
    bool matchBufferWithNext(const std::regex& pattern);

    /**
     *
     */
    bool matchBufferWithNext(int32_t registeredTokenType);

    /**
     *
     */
    bool matchCurrent(char ch);

    /**
     *
     */
    bool matchCurrent(const std::regex& pattern);

    /**
     *
     */
    bool matchCurrent(int32_t registeredTokenType);

    /**
     *
     */
    bool matchPrev(char ch);

    /**
     *
     */
    bool matchPrev(const std::regex& pattern);

    /**
     *
     */
    bool matchPrev(int32_t registeredTokenType);

    /**
     *
     */
    bool matchNext(char ch);

    /**
     *
     */
    bool matchNext(const std::regex& pattern);

    /**
     *
     */
    bool matchNext(int32_t registeredTokenType);

    /**
     *
     */
    char current() { return la(0); }

    /**
     *
     */
    char prev() { return la(-1); }

    /**
     *
     */
    char next() { return la(1); }

    /**
     *
     */
    bool currentExists();

    /**
     *
     */
    bool prevExists();

    /**
     *
     */
    bool nextExists();

    Token devour(int32_t registeredTokenType);

    /**
     *
     */
    void specReset();

    /**
     *
     */
    void specStart();

    /**
     *
     */
    bool specSuccess();

    /**
     *
     */
    bool specFail();

    /**
     *
     */
    void mark();

    /**
     *
     */
    void release();

    /**
     *
     */
    void seek(int32_t k);

    /**
     *
     */
    int32_t specPos() const;

    /**
     *
     */
    int32_t specUp();

    /**
     *
     */
    int32_t specDown();

    /**
     *
     */
    bool specMatch(char ch);

    /**
     *
     */
    bool specMatch(const std::regex& pattern);

    /**
     *
     */
    bool specMatch(int32_t registeredTokenType);

    /**
     *
     */
    bool specExists();

    /**
     *
     */
    char specCurrent();

    /**
     *
     */
    char specPrev();

    /**
     *
     */
    char specNext();

    /**
     *
     */
    bool isSpeculating() const { return !mMarkers.empty(); }

    /**
     *
     */
    char readChar();

    /**
     *
     */
    void advance();

    /**
     *
     */
    void advance(uint32_t n);

    /**
     *
     */
    void consume();

    //
    void consume(uint32_t n);

    /**
     *
     */
    void skip();

    /**
     *
     */
    void skipOnce(char ch);

    /**
     *
     */
    void skipAll(char ch);

    /**
     *
     */
    void skipOnce(const std::regex& pattern);

    /**
     *
     */
    void skipAll(const std::regex& pattern);

    /**
     *
     */
    void abrupt();

    SourcePosition getCurrentPosition();

    /**
     *
     */
    SourcePosition generatePosition(int32_t pos, uint32_t length);

    /**
     *
     */
    uint32_t computeLineNumberAtPosition(int32_t pos);

    /**
     *
     */
    int32_t computeIndexOnLineAtPosition(int32_t pos);

    /**
     *
     */
    char currentChar() const { return mPos >= 0 && mPos < mContent.length() ? mContent[mPos] : '\0'; }

    /**
     *
     */
    void unload();

    /**
     *
     */
    virtual Token readNext() = 0;
};

} // namespace hydro::compiler

#endif /* __h3o_internal_Lexer__ */
